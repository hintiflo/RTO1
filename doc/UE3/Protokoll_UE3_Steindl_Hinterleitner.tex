\documentclass{article}

\usepackage[utf8]{inputenc}
% \usepackage[latin1]{inputenc}
\usepackage[ngerman,naustrian]{babel}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{ulem}
\usepackage{here}
\usepackage[pdftex]{graphicx}
\usepackage{amsthm}
\usepackage{gensymb}
\usepackage{fancyhdr}
\usepackage[left=20mm,top=25mm,bottom=25mm,right=20mm,headheight=15mm,headsep=10mm,footskip=10mm]{geometry}
\usepackage{longtable}
\usepackage{hhline}
\usepackage[table]{xcolor}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathcomp}
\usepackage{tabularx}
\usepackage{multicol}
\usepackage{graphicx}
\renewcommand{\familydefault}{\sfdefault}
		% \sffamily

\newcommand{\bild}[3]{\begin{figure}[h!]		\begin{center}			\includegraphics[#3]{#1}			\caption{#2}		\end{center}	\end{figure}}

\begin{document}

%\pagestyle{empty}
\begin{titlepage}
	\begin{center}
		{\large{FH OÖ - Hagenberg \\ embedded systems design}\\\vspace*{4cm}}
		\small{RTO1 UE}\\
		\textbf{WS 2020}\\\vspace*{2cm}
		\Huge{\textbf{Protokoll}}\\\vspace*{1cm}
		\huge{Übung\,3: Entwicklung eines effizienten RTOS  \\ \large{ Erweiterung des Echtzeitbetriebssystems APOS} } \vspace*{90mm}
		
		\small{Simon Steindl  S2010567025	\\
		Florian Hinterleitner S2010567014	\\
		}
	\end{center}
\end{titlepage}

% \tableofcontents
% \newpage
% \setcounter{page}{18}
% \setcounter{section}{3}
 
% \section{}
% screenshots
% Timing-tabelle

\subsection*{Aufgabe A – Erweiterung prioritätsbasiertes Scheduling}
Die Priorisierung der Tasks ist implementiert in einer 'prioSufficient()'-Funktion und erfolgt nach dem Schema:
\begin{itemize}
\item	hat der nächste Task in der Queue ein höhere, oder zumindest gleiche Prio als der aktuelle,  erfolgt auch ein Switch.
\item	hat der nächste Task in der Queue ein kleinere, Prio als der aktuelle, und der aktuelle geht in den 'SUSPENDED' state, erfolgt auch ein Switch.
\item Andernfalls wird der aktuelle Task beibehalten.
\end{itemize}

Untersuchung der Funktion:
\begin{itemize}
\item Hat der Counter eine Prio von 1 (sehr unwichtig), laufen alle Tasks korrekt ab, jedoch erfolg das hochzählen des Counters merklich langsamer, als ohne Priorisierung.
\item Hat der Counter eine Prio von 100 (gleich wichtig), laufen alle Tasks korrekt ab, das hochzählen des Counters erfolgt wie gewohnt. Da alle Tasks in diesem Fall die selbe Prio haben, ergibt sich das selbe Verhalten wie ein Round Robin ohne Priorisierung.
\item Hat der Counter eine Prio von 200 (sehr wichtig), läuft nur noch dieser Task, seine Priorität lässt die anderen 'nicht zum zug kommen'.
\end{itemize}
Conclusio: Diese sehr primitiver Prio-Konzept erlaubt typischerweise, einzelne unwichtige Tasks nach unten zu priorisieren, einen einzelnen Task als sehr wichtig einzustufen und nach oben zu priorisieren, erfordert ausgeklügeltere Konzepte.
Eventuell würden auch Scheduler-calls aus einem Task hoher Priorität heraus das System wieder stabiler zum laufen bringen, jedoch ist man dadurch auf Kooperativität diese Tasks angewiesen.

\bild{BSP1_Prio_1.jpg}{Prio 1}{width=0.2\textwidth} 
\bild{BSP1_Prio_100.jpg}{Prio 100}{width=0.2\textwidth}
\bild{BSP1_Prio_200.jpg}{Prio 200}{width=0.2\textwidth}

\subsection*{Aufgabe B – Einbau eines Stack-Checkers}
Der Stack-Checker wurd realisiert mit 'defines' zum definieren des End-Markers, zum jeweiligen setzen des Markers pro Task, sowie eines Abfrage-Makros für den Marker.
Die eigentliche Validiering erfolgt jeweils beim TaskSwitch mit der Funktion 'verifyStackEnd()'. Diese vergleicht den tatsächlichen Marker und retourniert 'TRUE', wenn dieser ident mit dem Sollwert ist, das Stack-Ende also nicht überschrieben wurde.

\bild{Bsp2_pre}{Systick vor Stack-Checking}{width=0.4\textwidth}
\bild{Bsp2_post}{Systick nach Stack-Checking}{width=0.4\textwidth}

Der Overhead ergibt sich aus der Differenz der SysTick-werte vor \& nach dem stack-checking, sowie dem Prozessortakt:

\begin{itemize}
\item 0x0000a15b - 0x0000BB15 = 0x000019BA = 6586(Dez)
\item bei 48MHz Prozessortakt ergibt dies 137.2uS für das Stack-Checking.
\end{itemize}

% \subsection*{Aufgabe C – Task-Event-Handling}
% \includegraphics[width=.8\textwidth]{debugUnit}

% \subsection{Laufzeit jedes Tasks}
	% \begin{table}[h!]
		% \begin{center}		
			% \begin{tabular}{ l | l }	 % \hline
				% Task & Laufzeit in ms \\ \hline
				% Systick mit Mandelbrot	& 18.52s \\ \hline
				% Systick ohne Mandelbrot	& 29.39 	\\ \hline
				% Systick ohne GPIOs *)	& 29.38 \\ \hline
				% Counter	& 6.135 \\ \hline
				% Key& 4.895 \\ \hline
				% LED	& 4.894 \\ \hline
				% Watch	& 7.346 \\ \hline
				% Poti	& 6.115 \\ \hline
				% Mandelbrot	& 18.49s \\ %\hline
			% \end{tabular}
			% \caption{Laufzeiten des SysTicks, sowie der einzelnen Tasks}
		% \end{center}		
	% \end{table}
% \subsection{Overhead (Zyklen, µs) der Messung}
% Der Overhead, also das schalten der GPIOs, errechnet sich aus der Lauzeit des Systemzyklus mit und ohne*) GPIOs: 29.39ms - 29.38ms = 0.01ms ~= 10us. Der 8MHz-Quarz wird laut 
\end{document} 