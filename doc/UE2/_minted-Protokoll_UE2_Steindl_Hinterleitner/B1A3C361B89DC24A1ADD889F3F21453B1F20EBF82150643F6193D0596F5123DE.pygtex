\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}include} \PYG{c+cpf}{\PYGZlt{}stdlib.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}include} \PYG{c+cpf}{\PYGZlt{}stdint.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}include} \PYG{c+cpf}{\PYGZlt{}string.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}include} \PYG{c+cpf}{\PYGZdq{}Services/StdDef.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}include} \PYG{c+cpf}{\PYGZdq{}APOS.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}include} \PYG{c+cpf}{\PYGZdq{}BSP/systick.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}include} \PYG{c+cpf}{\PYGZdq{}stm32f0xx\PYGZus{}gpio.h\PYGZdq{}}

\PYG{c+cp}{\PYGZsh{}define DEBUG}

\PYG{k}{static} \PYG{k}{const} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{maxTasks} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k}{static} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{numTasks} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{static} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{currentTask} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{static} \PYG{n}{APOS\PYGZus{}TCB\PYGZus{}STRUCT}\PYG{o}{*} \PYG{n}{pTasks}\PYG{p}{[}\PYG{n}{maxTasks}\PYG{p}{];}


\PYG{k}{static} \PYG{k+kt}{void} \PYG{n+nf}{copyTasks}\PYG{p}{(}\PYG{n}{APOS\PYGZus{}TCB\PYGZus{}STRUCT}\PYG{o}{**} \PYG{n}{source}\PYG{p}{,} \PYG{n}{APOS\PYGZus{}TCB\PYGZus{}STRUCT}\PYG{o}{**} \PYG{n}{dest}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{size}\PYG{p}{)}
\PYG{p}{\PYGZob{}}	\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{size}\PYG{p}{;} \PYG{n}{i}\PYG{o}{++}\PYG{p}{)} 
	\PYG{p}{\PYGZob{}}	\PYG{p}{(}\PYG{o}{*}\PYG{n}{dest}\PYG{p}{)[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{o}{*}\PYG{n}{source}\PYG{p}{)[}\PYG{n}{i}\PYG{p}{];}
	\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
 
\PYG{k+kt}{void} \PYG{n+nf}{APOS\PYGZus{}Init}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}  													\PYG{c+c1}{// Initialisert das Echtzeitbetriebssystem}
\PYG{p}{\PYGZob{}}	
	\PYG{c+c1}{// NVIC\PYGZus{}InitTypeDef NVIC\PYGZus{}InitStruct;}
	\PYG{c+c1}{// NVIC\PYGZus{}InitStruct.NVIC\PYGZus{}IRQChannel = PendSV\PYGZus{}IRQn;}
	\PYG{c+c1}{// NVIC\PYGZus{}InitStruct.NVIC\PYGZus{}IRQChannelPriority = 0xF0;	// hoechster Wert: kleinste Prio}
	\PYG{c+c1}{// 																								// 0xF im oberen nibble: 0b11110000}
	\PYG{c+c1}{// NVIC\PYGZus{}InitStruct.NVIC\PYGZus{}IRQChannelCmd = ENABLE;	}
	\PYG{c+c1}{// NVIC\PYGZus{}Init(\PYGZam{}NVIC\PYGZus{}InitStruct);}
	\PYG{c+c1}{// }
	\PYG{c+c1}{// NVIC\PYGZus{}SetPriority(PendSV\PYGZus{}IRQn, 0xF0 );				}
	
	\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{numTasks}\PYG{p}{;} \PYG{n}{i}\PYG{o}{++}\PYG{p}{)} 
	\PYG{p}{\PYGZob{}}		\PYG{n}{pTasks}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{NULL}\PYG{p}{;}
	\PYG{p}{\PYGZcb{}}
	
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{void} \PYG{n+nf}{APOS\PYGZus{}TASK\PYGZus{}Create}\PYG{p}{(} \PYG{n}{APOS\PYGZus{}TCB\PYGZus{}STRUCT}\PYG{o}{*} \PYG{n}{pTask}\PYG{p}{,}  	\PYG{c+c1}{// TaskControlBlock}
					\PYG{c+cp}{\PYGZsh{}ifdef DEBUG}
						\PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{pTaskName}\PYG{p}{,} 								\PYG{c+c1}{// Task Name – nur fuer Debug\PYGZhy{}Zwecke}
					\PYG{c+cp}{\PYGZsh{}endif}
						\PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{Priority}\PYG{p}{,}  									\PYG{o}{//} \PYG{n}{Prioritaet} \PYG{n}{des} \PYG{n}{Tasks} \PYG{p}{(}\PYG{n}{vorerst} \PYG{n}{nicht} \PYG{n}{in} \PYG{n}{Verwendung}\PYG{p}{)}
						\PYG{k+kt}{void} \PYG{p}{(}\PYG{o}{*}\PYG{n}{pRoutine}\PYG{p}{)(}\PYG{k+kt}{void}\PYG{p}{),}  							\PYG{c+c1}{// Startadresse Task (ROM)}
						\PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{pStack}\PYG{p}{,} 												\PYG{c+c1}{// Startadresse Stack des Tasks (RAM)}
						\PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{StackSize}\PYG{p}{,}  									\PYG{c+c1}{// Groesse des Stacks}
						\PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{TimeSlice}  									\PYG{c+c1}{// Time\PYGZhy{}Slice fuer Round Robin Scheduling}
						\PYG{p}{)}
\PYG{p}{\PYGZob{}}
	\PYG{k}{if}\PYG{p}{(}\PYG{n}{pRoutine} \PYG{o}{==} \PYG{n+nb}{NULL}\PYG{p}{)}														\PYG{c+c1}{// Abbruch wenn keine gueltige Funktions\PYGZhy{}adresse}
		\PYG{k}{return}\PYG{p}{;}
	
	\PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{pTask}\PYG{p}{)}																			\PYG{c+c1}{// notwendigen Speicher fuer Task\PYGZhy{}Daten allokiern}
		\PYG{n}{pTask} \PYG{o}{=} \PYG{n}{calloc}\PYG{p}{(}\PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{APOS\PYGZus{}TCB\PYGZus{}STRUCT}\PYG{p}{),} \PYG{l+m+mi}{1}\PYG{p}{);}
	
	
	\PYG{c+cp}{\PYGZsh{}ifdef DEBUG}
	\PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{pTaskName}\PYG{p}{)}
		\PYG{k}{return}\PYG{p}{;}
	\PYG{n}{pTask}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{pTaskName} \PYG{o}{=} \PYG{n}{calloc}\PYG{p}{(}\PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{char}\PYG{p}{),} \PYG{n}{strlen}\PYG{p}{(}\PYG{n}{pTaskName}\PYG{p}{));}
	\PYG{n}{strcpy}\PYG{p}{(}\PYG{n}{pTask}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{pTaskName}\PYG{p}{,} \PYG{n}{pTaskName}\PYG{p}{);}
	\PYG{c+cp}{\PYGZsh{}endif}
	\PYG{n}{pTask}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{prio} \PYG{o}{=} \PYG{n}{Priority}\PYG{p}{;}													\PYG{c+c1}{// Task\PYGZhy{}Daten in den control block uebernehmen}
	\PYG{n}{pTask}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{routine} \PYG{o}{=} \PYG{n}{pRoutine}\PYG{p}{;}
	\PYG{n}{pTask}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{pStack} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{p}{)}\PYG{n}{pStack}\PYG{p}{;}
	\PYG{n}{pTask}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{timeSlice} \PYG{o}{=} \PYG{n}{TimeSlice}\PYG{p}{;}
	
	\PYG{k}{if}\PYG{p}{(}\PYG{n}{numTasks} \PYG{o}{\PYGZlt{}} \PYG{n}{maxTasks}\PYG{p}{)} \PYG{p}{\PYGZob{}}												
		\PYG{n}{pTasks}\PYG{p}{[}\PYG{n}{numTasks}\PYG{p}{]} \PYG{o}{=} \PYG{n}{pTask}\PYG{p}{;}											\PYG{c+c1}{// in der Task\PYGZhy{}Liste eintragen}
		\PYG{n}{numTasks}\PYG{o}{++}\PYG{p}{;}
	\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{APOS\PYGZus{}Start}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}  														\PYG{c+c1}{// Starten des Echtzeitbetriebssystems}
\PYG{p}{\PYGZob{}}
	\PYG{n}{APOS\PYGZus{}SetPSP}\PYG{p}{();}
	\PYG{n}{\PYGZus{}\PYGZus{}set\PYGZus{}CONTROL}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{);}				\PYG{c+c1}{// [0]=0 	privileged mode um IRQs enable/disable zu koennen}
													\PYG{c+c1}{// [1]=1 thread mode \PYGZhy{} Alternate stack pointer PSP is used. }
	\PYG{k}{while}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
		\PYG{n}{APOS\PYGZus{}Scheduler}\PYG{p}{();}															\PYG{c+c1}{// Scheduler in Endlos\PYGZhy{}Schleife ausfuehren}
\PYG{p}{\PYGZcb{}}
						
\PYG{k+kt}{void} \PYG{n+nf}{APOS\PYGZus{}Scheduler}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
	\PYG{k}{static} \PYG{k+kt}{int} \PYG{n}{lastTick} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
	\PYG{k+kt}{int} \PYG{n}{tick} \PYG{o}{=} \PYG{n}{Systick\PYGZus{}GetTick}\PYG{p}{();}
	\PYG{k}{if}\PYG{p}{(}\PYG{n}{lastTick} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{)}
		\PYG{n}{lastTick} \PYG{o}{=} \PYG{n}{tick}\PYG{p}{;}
	
	
	\PYG{c+c1}{//  if((tick \PYGZhy{} lastTick) \PYGZgt{}= pTasks[currentTask]\PYGZhy{}\PYGZgt{}timeSlice) // wenn timeSlice des aktuellen abgelaufen, dann}
	\PYG{k}{if}\PYG{p}{((}\PYG{n}{tick} \PYG{o}{\PYGZhy{}} \PYG{n}{lastTick}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)} 										\PYG{c+c1}{// wenn SysTick erhoeht wurde}
	\PYG{p}{\PYGZob{}}	\PYG{n}{currentTask}\PYG{o}{++}\PYG{p}{;}															\PYG{c+c1}{// auf naechsten Task schalten}
		\PYG{n}{currentTask} \PYG{o}{\PYGZpc{}=} \PYG{n}{numTasks}\PYG{p}{;}
		\PYG{n}{lastTick} \PYG{o}{=} \PYG{n}{Systick\PYGZus{}GetTick}\PYG{p}{();}
		\PYG{n}{setPendSV}\PYG{p}{();}																\PYG{c+c1}{// PendSV Handler ausloesen}
	\PYG{p}{\PYGZcb{}} \PYG{k}{else} 
	\PYG{p}{\PYGZob{}}	\PYG{n}{pTasks}\PYG{p}{[}\PYG{n}{currentTask}\PYG{p}{]}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{routine}\PYG{p}{();}	 						\PYG{c+c1}{// akutelle Task\PYGZhy{}Funktion callen}
	\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{APOS\PYGZus{}SetPSP}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}	\PYG{n}{\PYGZus{}\PYGZus{}set\PYGZus{}PSP}\PYG{p}{(}\PYG{n}{pTasks}\PYG{p}{[}\PYG{n}{currentTask}\PYG{p}{]}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{pStack}\PYG{p}{);}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void}	\PYG{n+nf}{setPendSV}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}	\PYG{c+c1}{// NVIC\PYGZus{}SetPendingIRQ(PendSV\PYGZus{}IRQn); ... wirkungslos, beobachtet beim debuggen}
	\PYG{n}{SCB}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{ICSR} \PYG{o}{|=} \PYG{n}{SCB\PYGZus{}ICSR\PYGZus{}PENDSVSET\PYGZus{}Msk}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// betreten einer critical region durch deaktivieren aller Interrupts}
\PYG{k+kt}{void} \PYG{n+nf}{APOS\PYGZus{}EnterRegion}\PYG{p}{()}	\PYG{c+c1}{// um einen task switch zu verhindern}
\PYG{p}{\PYGZob{}}	\PYG{c+c1}{// uint32\PYGZus{}t primask = \PYGZus{}\PYGZus{}get\PYGZus{}PRIMASK();}
	\PYG{n}{\PYGZus{}\PYGZus{}disable\PYGZus{}irq}\PYG{p}{();}
	\PYG{c+c1}{// primask = \PYGZus{}\PYGZus{}get\PYGZus{}PRIMASK(); 				...zum debuggen, ob IRQ wirklich deaktiviert wurde}
																				\PYG{c+c1}{// nach disable muss primask == 1 sein}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// verlassen einer critical region durch aktivieren aller Interrupts}
\PYG{k+kt}{void} \PYG{n+nf}{APOS\PYGZus{}LeaveRegion}\PYG{p}{()}	\PYG{c+c1}{// um task switch wieder zu ermoeglichen}
\PYG{p}{\PYGZob{}}	\PYG{c+c1}{//	uint32\PYGZus{}t primask = \PYGZus{}\PYGZus{}get\PYGZus{}PRIMASK();}
	\PYG{n}{\PYGZus{}\PYGZus{}enable\PYGZus{}irq}\PYG{p}{();}	\PYG{c+c1}{//  wirkungslos?}
	\PYG{c+c1}{// primask = \PYGZus{}\PYGZus{}get\PYGZus{}PRIMASK();					...zum debuggen, ob IRQ wirklich wieder aktiviert wurde}
																				\PYG{c+c1}{// nach disable muss primask == 0 sein}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// prufen, ob critical region schon vergeben ist, durch pruefen }
\PYG{c+c1}{// return 1 ... region vergeben}
\PYG{c+c1}{// return 0 ... region ist gerade frei}
\PYG{k+kt}{int} \PYG{n+nf}{APOS\PYGZus{}TestRegion}\PYG{p}{()}	\PYG{c+c1}{// ob priority mask der IRQs gesetzt wurde}
\PYG{p}{\PYGZob{}}	\PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{primask} \PYG{o}{=} \PYG{n}{\PYGZus{}\PYGZus{}get\PYGZus{}PRIMASK}\PYG{p}{();}		
	\PYG{k}{return} \PYG{n}{primask}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}	

\PYG{k+kt}{void} \PYG{n+nf}{APOS\PYGZus{}Delay} \PYG{p}{(}\PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{ticks}\PYG{p}{)}
\PYG{p}{\PYGZob{}}	\PYG{k}{static} \PYG{k+kt}{int} \PYG{n}{prevTick} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
	\PYG{k+kt}{int} \PYG{n}{tick} \PYG{o}{=} \PYG{n}{Systick\PYGZus{}GetTick}\PYG{p}{();}
	\PYG{k}{if}\PYG{p}{(}\PYG{n}{prevTick} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{)}
		\PYG{n}{prevTick} \PYG{o}{=} \PYG{n}{tick}\PYG{p}{;}
	
	\PYG{k}{while}\PYG{p}{((}\PYG{n}{tick} \PYG{o}{\PYGZhy{}} \PYG{n}{prevTick}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{ticks}\PYG{p}{)}
	\PYG{p}{\PYGZob{}}
		\PYG{n}{\PYGZus{}\PYGZus{}NOP}\PYG{p}{;}
	\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}
